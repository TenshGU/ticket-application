//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//

package org.springframework.web.cors;

import java.time.Duration;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import org.springframework.http.HttpMethod;
import org.springframework.lang.Nullable;
import org.springframework.util.CollectionUtils;
import org.springframework.util.ObjectUtils;
import org.springframework.util.StringUtils;

public class CorsConfiguration {
    public static final String ALL = "*";
    private static final List<String> ALL_LIST = Collections.unmodifiableList(Collections.singletonList("*"));
    private static final CorsConfiguration.OriginPattern ALL_PATTERN = new CorsConfiguration.OriginPattern("*");
    private static final List<CorsConfiguration.OriginPattern> ALL_PATTERN_LIST;
    private static final List<String> DEFAULT_PERMIT_ALL;
    private static final List<HttpMethod> DEFAULT_METHODS;
    private static final List<String> DEFAULT_PERMIT_METHODS;
    @Nullable
    private List<String> allowedOrigins;
    @Nullable
    private List<CorsConfiguration.OriginPattern> allowedOriginPatterns;
    @Nullable
    private List<String> allowedMethods;
    @Nullable
    private List<HttpMethod> resolvedMethods;
    @Nullable
    private List<String> allowedHeaders;
    @Nullable
    private List<String> exposedHeaders;
    @Nullable
    private Boolean allowCredentials;
    @Nullable
    private Long maxAge;

    public CorsConfiguration() {
        this.resolvedMethods = DEFAULT_METHODS;
    }

    public CorsConfiguration(CorsConfiguration other) {
        this.resolvedMethods = DEFAULT_METHODS;
        this.allowedOrigins = other.allowedOrigins;
        this.allowedOriginPatterns = other.allowedOriginPatterns;
        this.allowedMethods = other.allowedMethods;
        this.resolvedMethods = other.resolvedMethods;
        this.allowedHeaders = other.allowedHeaders;
        this.exposedHeaders = other.exposedHeaders;
        this.allowCredentials = other.allowCredentials;
        this.maxAge = other.maxAge;
    }

    public void setAllowedOrigins(@Nullable List<String> allowedOrigins) {
        this.allowedOrigins = allowedOrigins != null ? new ArrayList(allowedOrigins) : null;
    }

    @Nullable
    public List<String> getAllowedOrigins() {
        return this.allowedOrigins;
    }

    public void addAllowedOrigin(String origin) {
        if (this.allowedOrigins == null) {
            this.allowedOrigins = new ArrayList(4);
        } else if (this.allowedOrigins == DEFAULT_PERMIT_ALL && CollectionUtils.isEmpty(this.allowedOriginPatterns)) {
            this.setAllowedOrigins(DEFAULT_PERMIT_ALL);
        }

        this.allowedOrigins.add(origin);
    }

    public CorsConfiguration setAllowedOriginPatterns(@Nullable List<String> allowedOriginPatterns) {
        if (allowedOriginPatterns == null) {
            this.allowedOriginPatterns = null;
        } else {
            this.allowedOriginPatterns = new ArrayList(allowedOriginPatterns.size());
            Iterator var2 = allowedOriginPatterns.iterator();

            while(var2.hasNext()) {
                String patternValue = (String)var2.next();
                this.addAllowedOriginPattern(patternValue);
            }
        }

        return this;
    }

    @Nullable
    public List<String> getAllowedOriginPatterns() {
        return this.allowedOriginPatterns == null ? null : (List)this.allowedOriginPatterns.stream().map(CorsConfiguration.OriginPattern::getDeclaredPattern).collect(Collectors.toList());
    }

    public void addAllowedOriginPattern(String originPattern) {
        if (this.allowedOriginPatterns == null) {
            this.allowedOriginPatterns = new ArrayList(4);
        }

        this.allowedOriginPatterns.add(new CorsConfiguration.OriginPattern(originPattern));
        if (this.allowedOrigins == DEFAULT_PERMIT_ALL) {
            this.allowedOrigins = null;
        }

    }

    public void setAllowedMethods(@Nullable List<String> allowedMethods) {
        this.allowedMethods = allowedMethods != null ? new ArrayList(allowedMethods) : null;
        if (!CollectionUtils.isEmpty(allowedMethods)) {
            this.resolvedMethods = new ArrayList(allowedMethods.size());
            Iterator var2 = allowedMethods.iterator();

            while(var2.hasNext()) {
                String method = (String)var2.next();
                if ("*".equals(method)) {
                    this.resolvedMethods = null;
                    break;
                }

                this.resolvedMethods.add(HttpMethod.resolve(method));
            }
        } else {
            this.resolvedMethods = DEFAULT_METHODS;
        }

    }

    @Nullable
    public List<String> getAllowedMethods() {
        return this.allowedMethods;
    }

    public void addAllowedMethod(HttpMethod method) {
        this.addAllowedMethod(method.name());
    }

    public void addAllowedMethod(String method) {
        if (StringUtils.hasText(method)) {
            if (this.allowedMethods == null) {
                this.allowedMethods = new ArrayList(4);
                this.resolvedMethods = new ArrayList(4);
            } else if (this.allowedMethods == DEFAULT_PERMIT_METHODS) {
                this.setAllowedMethods(DEFAULT_PERMIT_METHODS);
            }

            this.allowedMethods.add(method);
            if ("*".equals(method)) {
                this.resolvedMethods = null;
            } else if (this.resolvedMethods != null) {
                this.resolvedMethods.add(HttpMethod.resolve(method));
            }
        }

    }

    public void setAllowedHeaders(@Nullable List<String> allowedHeaders) {
        this.allowedHeaders = allowedHeaders != null ? new ArrayList(allowedHeaders) : null;
    }

    @Nullable
    public List<String> getAllowedHeaders() {
        return this.allowedHeaders;
    }

    public void addAllowedHeader(String allowedHeader) {
        if (this.allowedHeaders == null) {
            this.allowedHeaders = new ArrayList(4);
        } else if (this.allowedHeaders == DEFAULT_PERMIT_ALL) {
            this.setAllowedHeaders(DEFAULT_PERMIT_ALL);
        }

        this.allowedHeaders.add(allowedHeader);
    }

    public void setExposedHeaders(@Nullable List<String> exposedHeaders) {
        this.exposedHeaders = exposedHeaders != null ? new ArrayList(exposedHeaders) : null;
    }

    @Nullable
    public List<String> getExposedHeaders() {
        return this.exposedHeaders;
    }

    public void addExposedHeader(String exposedHeader) {
        if (this.exposedHeaders == null) {
            this.exposedHeaders = new ArrayList(4);
        }

        this.exposedHeaders.add(exposedHeader);
    }

    public void setAllowCredentials(@Nullable Boolean allowCredentials) {
        this.allowCredentials = allowCredentials;
    }

    @Nullable
    public Boolean getAllowCredentials() {
        return this.allowCredentials;
    }

    public void setMaxAge(Duration maxAge) {
        this.maxAge = maxAge.getSeconds();
    }

    public void setMaxAge(@Nullable Long maxAge) {
        this.maxAge = maxAge;
    }

    @Nullable
    public Long getMaxAge() {
        return this.maxAge;
    }

    public CorsConfiguration applyPermitDefaultValues() {
        if (this.allowedOrigins == null && this.allowedOriginPatterns == null) {
            this.allowedOrigins = DEFAULT_PERMIT_ALL;
        }

        if (this.allowedMethods == null) {
            this.allowedMethods = DEFAULT_PERMIT_METHODS;
            this.resolvedMethods = (List)DEFAULT_PERMIT_METHODS.stream().map(HttpMethod::resolve).collect(Collectors.toList());
        }

        if (this.allowedHeaders == null) {
            this.allowedHeaders = DEFAULT_PERMIT_ALL;
        }

        if (this.maxAge == null) {
            this.maxAge = 1800L;
        }

        return this;
    }

    public void validateAllowCredentials() {
        if (this.allowCredentials == Boolean.TRUE && this.allowedOrigins != null && this.allowedOrigins.contains("*")) {
            throw new IllegalArgumentException("When allowCredentials is true, allowedOrigins cannot contain the special value \"*\" since that cannot be set on the \"Access-Control-Allow-Origin\" response header. To allow credentials to a set of origins, list them explicitly or consider using \"allowedOriginPatterns\" instead.");
        }
    }

    @Nullable
    public CorsConfiguration combine(@Nullable CorsConfiguration other) {
        if (other == null) {
            return this;
        } else {
            CorsConfiguration config = new CorsConfiguration(this);
            List<String> origins = this.combine(this.getAllowedOrigins(), other.getAllowedOrigins());
            List<CorsConfiguration.OriginPattern> patterns = this.combinePatterns(this.allowedOriginPatterns, other.allowedOriginPatterns);
            config.allowedOrigins = origins == DEFAULT_PERMIT_ALL && !CollectionUtils.isEmpty(patterns) ? null : origins;
            config.allowedOriginPatterns = patterns;
            config.setAllowedMethods(this.combine(this.getAllowedMethods(), other.getAllowedMethods()));
            config.setAllowedHeaders(this.combine(this.getAllowedHeaders(), other.getAllowedHeaders()));
            config.setExposedHeaders(this.combine(this.getExposedHeaders(), other.getExposedHeaders()));
            Boolean allowCredentials = other.getAllowCredentials();
            if (allowCredentials != null) {
                config.setAllowCredentials(allowCredentials);
            }

            Long maxAge = other.getMaxAge();
            if (maxAge != null) {
                config.setMaxAge(maxAge);
            }

            return config;
        }
    }

    private List<String> combine(@Nullable List<String> source, @Nullable List<String> other) {
        if (other == null) {
            return source != null ? source : Collections.emptyList();
        } else if (source == null) {
            return other;
        } else if (source != DEFAULT_PERMIT_ALL && source != DEFAULT_PERMIT_METHODS) {
            if (other != DEFAULT_PERMIT_ALL && other != DEFAULT_PERMIT_METHODS) {
                if (!source.contains("*") && !other.contains("*")) {
                    Set<String> combined = new LinkedHashSet(source.size() + other.size());
                    combined.addAll(source);
                    combined.addAll(other);
                    return new ArrayList(combined);
                } else {
                    return ALL_LIST;
                }
            } else {
                return source;
            }
        } else {
            return other;
        }
    }

    private List<CorsConfiguration.OriginPattern> combinePatterns(@Nullable List<CorsConfiguration.OriginPattern> source, @Nullable List<CorsConfiguration.OriginPattern> other) {
        if (other == null) {
            return source != null ? source : Collections.emptyList();
        } else if (source == null) {
            return other;
        } else if (!source.contains(ALL_PATTERN) && !other.contains(ALL_PATTERN)) {
            Set<CorsConfiguration.OriginPattern> combined = new LinkedHashSet(source.size() + other.size());
            combined.addAll(source);
            combined.addAll(other);
            return new ArrayList(combined);
        } else {
            return ALL_PATTERN_LIST;
        }
    }

    @Nullable
    public String checkOrigin(@Nullable String requestOrigin) {
        if (!StringUtils.hasText(requestOrigin)) {
            return null;
        } else {
            Iterator var2;
            if (!ObjectUtils.isEmpty(this.allowedOrigins)) {
                if (this.allowedOrigins.contains("*")) {
                    this.validateAllowCredentials();
                    return "*";
                }

                var2 = this.allowedOrigins.iterator();

                while(var2.hasNext()) {
                    String allowedOrigin = (String)var2.next();
                    if (requestOrigin.equalsIgnoreCase(allowedOrigin)) {
                        return requestOrigin;
                    }
                }
            }

            if (!ObjectUtils.isEmpty(this.allowedOriginPatterns)) {
                var2 = this.allowedOriginPatterns.iterator();

                while(var2.hasNext()) {
                    CorsConfiguration.OriginPattern p = (CorsConfiguration.OriginPattern)var2.next();
                    if (p.getDeclaredPattern().equals("*") || p.getPattern().matcher(requestOrigin).matches()) {
                        return requestOrigin;
                    }
                }
            }

            return null;
        }
    }

    @Nullable
    public List<HttpMethod> checkHttpMethod(@Nullable HttpMethod requestMethod) {
        if (requestMethod == null) {
            return null;
        } else if (this.resolvedMethods == null) {
            return Collections.singletonList(requestMethod);
        } else {
            return this.resolvedMethods.contains(requestMethod) ? this.resolvedMethods : null;
        }
    }

    @Nullable
    public List<String> checkHeaders(@Nullable List<String> requestHeaders) {
        if (requestHeaders == null) {
            return null;
        } else if (requestHeaders.isEmpty()) {
            return Collections.emptyList();
        } else if (ObjectUtils.isEmpty(this.allowedHeaders)) {
            return null;
        } else {
            boolean allowAnyHeader = this.allowedHeaders.contains("*");
            List<String> result = new ArrayList(requestHeaders.size());
            Iterator var4 = requestHeaders.iterator();

            while(true) {
                while(true) {
                    String requestHeader;
                    do {
                        if (!var4.hasNext()) {
                            return result.isEmpty() ? null : result;
                        }

                        requestHeader = (String)var4.next();
                    } while(!StringUtils.hasText(requestHeader));

                    requestHeader = requestHeader.trim();
                    if (allowAnyHeader) {
                        result.add(requestHeader);
                    } else {
                        Iterator var6 = this.allowedHeaders.iterator();

                        while(var6.hasNext()) {
                            String allowedHeader = (String)var6.next();
                            if (requestHeader.equalsIgnoreCase(allowedHeader)) {
                                result.add(requestHeader);
                                break;
                            }
                        }
                    }
                }
            }
        }
    }

    static {
        ALL_PATTERN_LIST = Collections.unmodifiableList(Collections.singletonList(ALL_PATTERN));
        DEFAULT_PERMIT_ALL = Collections.unmodifiableList(Collections.singletonList("*"));
        DEFAULT_METHODS = Collections.unmodifiableList(Arrays.asList(HttpMethod.GET, HttpMethod.HEAD));
        DEFAULT_PERMIT_METHODS = Collections.unmodifiableList(Arrays.asList(HttpMethod.GET.name(), HttpMethod.HEAD.name(), HttpMethod.POST.name()));
    }

    private static class OriginPattern {
        private final String declaredPattern;
        private final Pattern pattern;

        OriginPattern(String declaredPattern) {
            this.declaredPattern = declaredPattern;
            this.pattern = toPattern(declaredPattern);
        }

        private static Pattern toPattern(String patternValue) {
            patternValue = "\\Q" + patternValue + "\\E";
            patternValue = patternValue.replace("*", "\\E.*\\Q");
            return Pattern.compile(patternValue);
        }

        public String getDeclaredPattern() {
            return this.declaredPattern;
        }

        public Pattern getPattern() {
            return this.pattern;
        }

        public boolean equals(Object other) {
            if (this == other) {
                return true;
            } else {
                return other != null && this.getClass().equals(other.getClass()) ? ObjectUtils.nullSafeEquals(this.declaredPattern, ((CorsConfiguration.OriginPattern)other).declaredPattern) : false;
            }
        }

        public int hashCode() {
            return this.declaredPattern.hashCode();
        }

        public String toString() {
            return this.declaredPattern;
        }
    }
}
